grammar Lupin::Parser
  rule lua
    chunk
  end
  
  rule chunk
    list:stat* { matches.map(&:value) }
  end
  
  rule stat
    (statement:
     ( exp
     )
     WS? ';'?
    ) {
      statement.value
    }
  end
  
  rule exp
    ( 'nil' { Lupin::AST::Nil.new }
    | 'false' { Lupin::AST::False.new }
    | 'true' { Lupin::AST::True.new }
    | number
    | string
    )
  end
  
  rule number
    (base:/\d*\.\d+|\d+\.?/ { to_f }
     e:exponent? { matches.length > 0 ? exponent.value : 0 }
    ) { Lupin::AST::Number.new(base.value, e.value) }
  end
  
  rule exponent
    ([Ee] e:/[+-]?\d+/) { e.to_i }
  end  
  
  rule string
    ( ("\"" s:/(\\(?:['"abfnrtv\n\r]|\d{1,3})|[^"\n])*/ "\"") { Lupin::AST::String.new(s.value) }
    | ("\'" s:/(\\(?:['"abfnrtv\n\r]|\d{1,3})|[^'\n])*/ "\'") { Lupin::AST::String.new(s.value) }
    | /\[(=*)\[.*?\]\1\]/m { Lupin::AST::LongString.new(match(/\[(=*)\[(.*?)\]\1\]/m)[2]) }
    )
  end
  
  rule WS
    /[ \n\t]+/ { nil }
  end
end

grammar Lupin::Addition
  rule addition
    a:number WS? '+' WS? b:number {
      a.value + b.value
    }
  end
  
  rule number
    (sign /\d*\.\d+|\d+\.?/ exp?) { sign.value * to_f }
  end
  
  rule exp
    ([Ee] sign:sign digits:/\d+/) { digits.value.to_i * sign.value }
  end
  
  rule sign
    (sign:[-+]? WS*) { sign.value == '-' ? -1 : 1 }
  end
  
  rule WS
    [ \n\t]
  end
end
