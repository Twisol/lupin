grammar Lupin::Parser
  rule lua
    chunk
  end
  
  rule chunk
    list:statement* { matches.map(&:value) }
  end
  
  rule statement
    (stat:( functioncall
          )
     WS? ';'?
    ) { stat.value }
  end
  
  rule identifier
    /[A-Za-z_][A-Za-z_0-9]*/
  end
  
  ### Function invocation
  rule functioncall
    (var:( variable
         | ('(' WS? expression WS? ')') { expression.value }
         )
     args:args+
    ) {
      f = var.value
      args.matches.each {|a| f = Lupin::AST::FunctionCall.new(f, a.value)}
      f
    }
  end
  
  rule args
    ( ('(' WS? explist WS? ')' WS?) { explist.value }
    | ('(' WS? ')' WS?) { [] }
    | (table WS?) { [table] }
    | (string WS?) { [string] }
    )
  end
  
  ### Variable access
  rule variable
    ( (identifier '') { Lupin::AST::TableGet.new(nil, identifier.value) }
  # | prefix_expr WS? '[' WS? expression WS? ']'
  # | prefix_expr WS? '.' identifier
    )
  end
  
  ####
  ## Expressions (Operators & Precedence)
  #
  # ()
  # ^
  # not -(unary)
  # * /
  # + -
  # ..
  # < > <= >= ~= ==
  # and
  # or
  #
  ##
  ####
  
  rule explist
    (e:expression
     list:(WS? ',' WS? e:expression)*
    ) {
      [self].concat(list.matches).map {|m| m.e.value}
    }
  end
  
  rule expression
    or_expr
  end
  
  rule or_expr
    ( (lhs:and_expr
       op:(WS 'or' WS) { Lupin::AST::OrComp }
       rhs:or_expr
      ) { op.value.new(lhs.value, rhs.value) }
    | and_expr
    )
  end
  
  rule and_expr
    ( (lhs:eql_expr
       op:(WS 'and' WS) { Lupin::AST::AndComp }
       rhs:and_expr
      ) { op.value.new(lhs.value, rhs.value) }
    | eql_expr
    )
  end
  
  rule eql_expr
    ( (lhs:concat_expr
       op:( (WS? '<' WS?) { Lupin::AST::LessThan }
          | (WS? '>' WS?) { Lupin::AST::GreaterThan }
          | (WS? '<=' WS?) { Lupin::AST::AtMost }
          | (WS? '>=' WS?) { Lupin::AST::AtLeast }
          | (WS? '~=' WS?) { Lupin::AST::NotEqual }
          | (WS? '==' WS?) { Lupin::AST::Equal }
          )
       rhs:eql_expr
      ) { op.value.new(lhs.value, rhs.value) }
    | concat_expr
    )
  end
  
  rule concat_expr
    ( (lhs:add_expr
       op:(WS? '..' WS?) { Lupin::AST::Concatenate }
       rhs:concat_expr
      ) { op.value.new(lhs.value, rhs.value) }
    | add_expr
    )
  end
  
  rule add_expr
    ( (lhs:mul_expr
       op:( (WS? '+' WS?) { Lupin::AST::Addition }
          | (WS? '-' WS?) { Lupin::AST::Subtraction }
          )
       rhs:add_expr
      ) { op.value.new(lhs.value, rhs.value) }
    | mul_expr
    )
  end
  
  rule mul_expr
    ( (lhs:not_expr
       op:( (WS? '*' WS?) { Lupin::AST::Multiplication }
          | (WS? '/' WS?) { Lupin::AST::Division }
          )
       rhs:mul_expr
      ) { op.value.new(lhs.value, rhs.value) }
    | not_expr
    )
  end
  
  rule not_expr
    ( ( (lhs:pow_expr
         op:(WS 'not' WS) { Lupin::AST::Negation }
         rhs:not_expr
        ) { op.value.new(lhs.value, rhs.value) }
      | (op:('-' WS?) { Lupin::AST::UnaryMinus }
         rhs:pow_expr
        ) { op.value.new(rhs.value) }
      )
    | pow_expr
    )
  end
  
  rule pow_expr
    ( (lhs:basic_expr
       op:(WS? '^' WS?) { Lupin::AST::Power }
       rhs:pow_expr
      ) { op.value.new(lhs.value, rhs.value) }
    | basic_expr
    )
  end
  
  rule basic_expr
    ( prefix_expr | primitive )
  end
  
  rule prefix_expr
    ( ('(' WS? expression WS? ')') { expression.value }
    | variable
    | functioncall
    )
  end
  
  
  ####
  ## Basic data types
  ####
  rule primitive
    ( table
    | number
    | string
    | 'nil' { Lupin::AST::Nil.new }
    | 'false' { Lupin::AST::False.new }
    | 'true' { Lupin::AST::True.new }
    )
  end
  
  ### Table
  rule table
    ( ('{' WS? fieldlist WS? '}') { Lupin::AST::Table.new(fieldlist.value) }
    | ('{' WS? '}') { Lupin::AST::Table.new }
    )
  end
  
  rule fieldlist
    (f:field
     list:(WS? fieldsep WS? f:field)*
     WS? fieldsep?
    ) {
      [self].concat(list.matches).map {|m| m.f.value}
    }
  end
  
  rule field
    ( ('[' WS? k:expression WS? ']' WS? '=' WS? v:expression)
        { [k.value, v.value] }
    | (k:identifier WS? '=' WS? v:expression)
        { [k.value, v.value] }
    | (v:expression '')
        { [nil, v.value] }
    )
  end
  
  rule fieldsep
    ';' | ','
  end
  
  ### Number
  rule number
    ( /0x[A-Fa-f0-9]+/ { Lupin::AST::Number.new(to_i(16)) }
    | (base exponent) { Lupin::AST::Number.new(base.value, exponent.value) }
    | (base '') { Lupin::AST::Number.new(base.value) }
    )
  end
  
  rule base
    /\d*\.\d+|\d+\.?/ { to_f }
  end
  
  rule exponent
    ([Ee] e:/[+-]?\d+/) { e.to_i }
  end  
  
  ### String
  rule string
    ( ("\"" s:/(\\(?:['"abfnrtv\n\r]|\d{1,3})|[^"\n])*/ "\"") { Lupin::AST::String.new(s.value) }
    | ("\'" s:/(\\(?:['"abfnrtv\n\r]|\d{1,3})|[^'\n])*/ "\'") { Lupin::AST::String.new(s.value) }
    | /\[(=*)\[.*?\]\1\]/m { Lupin::AST::LongString.new(match(/\[(=*)\[(.*?)\]\1\]/m)[2]) }
    )
  end
  #'#
  
  ### Whitespace and comments
  rule WS
    (/[ \n\t]+/ | comment)+
  end
  
  rule comment
    "--" (/\[(=*)\[.*?\]\1\]/ | /.*\n/)
  end
end
