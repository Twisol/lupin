grammar Lupin::Parser
  rule lua
    chunk
  end
  
  rule chunk
    list:stat* { matches.map(&:value) }
  end
  
  rule stat
    (statement:exp WS? ';'?) {
      statement.value
    }
  end
  
  rule exp
    (lhs:primitive
     r:(WS? op:bin_op WS? rhs:exp)?
    ) {
      if r == ''
        lhs.value
      else
        op, rhs = r.matches[0].op, r.matches[0].rhs
        op.value.new(lhs.value, rhs.value)
      end
    }
  end
  
  rule bin_op
    ( '+' { Lupin::AST::Addition }
    | '-' { Lupin::AST::Subtraction }
    | '*' { Lupin::AST::Multiplication }
    | '/' { Lupin::AST::Division }
    )
  end
  
  rule primitive
    ( table
    | number
    | string
    | 'nil' { Lupin::AST::Nil.new }
    | 'false' { Lupin::AST::False.new }
    | 'true' { Lupin::AST::True.new }
    )
  end
  
  rule table
    ('{' WS? list:fieldlist WS? '}') {
      Lupin::AST::Table.new(list.value)
    }
  end
  
  rule fieldlist
    (f:field
     list:(WS? fieldsep WS? f:field)*
     WS? fieldsep?
    ) {
      [self].concat(list.matches).map {|m| m.f.value}
    }
  end
  
  rule field
    ( ('[' WS? k:exp WS? ']' WS? '=' WS? v:exp)
        { Lupin::AST::Field.new(k.value, v.value) }
    | (exp:exp '')
        { Lupin::AST::Field.new(nil, exp.value) }
    )
  end
  
  rule fieldsep
    ';' | ','
  end
  
  rule identifier
    /[A-Za-z_][A-Za-z0-9]*/ { Lupin::AST::String.new(to_s) }
  end
  
  rule number
    (base:/\d*\.\d+|\d+\.?/ { to_f }
     e:exponent? { matches.length > 0 ? exponent.value : 0 }
    ) { Lupin::AST::Number.new(base.value, e.value) }
  end
  
  rule exponent
    ([Ee] e:/[+-]?\d+/) { e.to_i }
  end  
  
  rule string
    ( ("\"" s:/(\\(?:['"abfnrtv\n\r]|\d{1,3})|[^"\n])*/ "\"") { Lupin::AST::String.new(s.value) }
    | ("\'" s:/(\\(?:['"abfnrtv\n\r]|\d{1,3})|[^'\n])*/ "\'") { Lupin::AST::String.new(s.value) }
    | /\[(=*)\[.*?\]\1\]/m { Lupin::AST::LongString.new(match(/\[(=*)\[(.*?)\]\1\]/m)[2]) }
    )
  end
  
  rule WS
    /[ \n\t]+/ { nil }
  end
end
